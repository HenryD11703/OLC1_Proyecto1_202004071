package Analizador;
//importaciones si fuese necesario
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import org.jfree.data.category.DefaultCategoryDataset;




//codigo de la clase parser
//
//data.put("myKey", new HashMap<Integer, Integer>());

//declarar el hashmap con valores de tipo
// Int para el numero de la tabla
// String para guardar el tipo de dato
// String para el nombre del dato
// Hasmap de tipo string , tipo hashmap 


parser code 
{:
    StringBuilder printString = new StringBuilder();
    HashMap<Object,Object> data = new HashMap<>(); 
    public void syntax_error(Symbol s){
        System.out.println("Error Sintactico: "+s.value+" en la linea: "+(s.left)+" en la columna: "+(s.right));
    }

    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error Sintactico irrecuperable: "+s.value+" en la linea: "+(s.left)+" en la columna: "+(s.right));
    }
    public void addPrintExpression(String expr) {
        printString.append(expr);
    }
     public String getImpresiones() {
        return printString.toString();
    }
:}

action code
{:
    String codigoUsr="";
:}

terminal DOSP, MENORQ, MAYORQ, PYCOMA, CORA, CORC, ARRB, PARA, PARC, COMA, IGUAL, MENOS;
terminal TK_PROGRAM, TK_VAR, TK_CADENA, TK_CHAR, TK_END, TK_ARR, TK_SUM, TK_RES;
terminal TK_MUL, TK_DIV, TK_MOD, TK_MEDIA, TK_MEDIANA, TK_MODA, TK_VARIANZA, TK_MAX, TK_MIN;
terminal TK_CONSOLE, TK_PRINT, TK_COLUMN, TK_GRAPHBAR, TK_GRAPHPIE, TK_GRAPHLINE, TK_HISTOGRAM;
terminal TK_TITULO, TK_EJEX, TK_EJEY, TK_TITULOX, TK_TITULOY, TK_EXEC, TK_VALUES, TK_LABEL;
terminal String ENTEROS, DECIMAL, STRINGT, NOMBRES;


nonterminal INICIO, CODIGO, OTROCODIGO, VARIABLE, ARREGLO, IDARREGLO, LISTA_VALORES;
nonterminal OTRA_EXPRESION, TIPO, EXPRESION, OPERACION, ESTADISTICA, DATOS;
nonterminal IMPRESION, TIPOIMPRESION, ARREGLOIMP, GRAFICA, TIPOGRAPH, INSTRUCCION, TIPOINSTRUCCION, OTRAINSTRUCCION;
nonterminal EXPRESIONGRAPH, OTRAEXPRESIONIMP;


start with INICIO;

INICIO ::= TK_PROGRAM  CODIGO OTROCODIGO TK_END TK_PROGRAM;

CODIGO ::= VARIABLE 
          | ARREGLO 
          | OPERACION 
          | ESTADISTICA 
          | IMPRESION 
          | GRAFICA
          | error TK_END PYCOMA;
 
OTROCODIGO ::= OTROCODIGO CODIGO
            | /* vacio */; 


VARIABLE ::= TK_VAR DOSP TIPO:t DOSP DOSP NOMBRES:n MENORQ MENOS EXPRESION:e {: RESULT = e; :} TK_END PYCOMA 
{:

    data.put(n.toString(), e);
    for (Object clave : data.keySet()) {
        System.out.println("Clave: " + clave.toString() + " |    Valor: " + data.get(clave).toString());
    }
:}
;

ARREGLO ::= TK_ARR DOSP TIPO:At DOSP DOSP IDARREGLO:Ai MENORQ MENOS LISTA_VALORES:Av TK_END PYCOMA
{:
    data.put(Ai, Av);
    ArrayList<Object> miLista = (ArrayList<Object>) data.get(Ai);
    for(Object valor: miLista){
        System.out.println("Valores para: "+Ai+" son:"+valor);
    }
    
:};

TIPO ::= TK_CHAR {: RESULT = "char[]"; :} 
        | TK_CADENA {: RESULT = "String"; :};

IDARREGLO ::= ARRB NOMBRES:nombreA
{:
    RESULT = nombreA;
:}
;

LISTA_VALORES ::= CORA EXPRESION:Le OTRA_EXPRESION:Loe CORC
{:
    ArrayList<Object> lista = new ArrayList<>();
    lista.add(Le);//este añade el primer valor que se obtiene
    lista.addAll((Collection<? extends Object>) Loe); //esto indica que Loe puede ser cualquier cosa que sea de tipo Object
    
    RESULT = lista;
    
:};


OTRA_EXPRESION ::= COMA EXPRESION:exp OTRA_EXPRESION:otraexp  
               {:
    ArrayList<Object> lista;
    if (otraexp == null) {
        lista = new ArrayList<>();
    } else {
        lista = (ArrayList<Object>) otraexp;
    }
    lista.add(0,exp);
    RESULT = lista;
:}
| /* vacio */
{:
    RESULT = new ArrayList<>();
:};
                
EXPRESION ::= ENTEROS:E {: RESULT=E; :} 
             | DECIMAL:E {: RESULT=E; :} 
             | STRINGT:E {: RESULT=E; :} 
             | NOMBRES:E {: 
                            RESULT=data.get(E); 
                         :} 
             | OPERACION:E {: RESULT=E; :} 
             | IDARREGLO:E {: //Para cuando sean arreglos guarlos y retornar el arreglo
                           RESULT=data.get(E); 
                            :} 
             | ESTADISTICA: E {: RESULT=E; :};

OPERACION ::=     TK_SUM PARA EXPRESION:ns1 COMA EXPRESION:ns2 PARC
                  {: 
                    double n1 = Double.parseDouble(ns1.toString());
                    double n2 = Double.parseDouble(ns2.toString());
                    RESULT = n1 + n2;
                  :}
                | TK_RES PARA EXPRESION:nr1 COMA EXPRESION:nr2 PARC
                    {: 
                        double n1 = Double.parseDouble(nr1.toString());
                        double n2 = Double.parseDouble(nr2.toString());
                        RESULT = n1 - n2;
                    :}
                | TK_MUL PARA EXPRESION:nm1 COMA EXPRESION:nm2 PARC
                    {: 
                        double n1 = Double.parseDouble(nm1.toString());
                        double n2 = Double.parseDouble(nm2.toString());
                        RESULT = n1 * n2;
                    :}
                | TK_DIV PARA EXPRESION:nd1 COMA EXPRESION:nd2 PARC
                    {: 
                        double n1 = Double.parseDouble(nd1.toString());
                        double n2 = Double.parseDouble(nd2.toString());
                        RESULT = n1 / n2;
                    :}
                | TK_MOD PARA EXPRESION:mn1 COMA EXPRESION:mn2 PARC
                    {: 
                        double n1 = Double.parseDouble(mn1.toString());
                        double n2 = Double.parseDouble(mn2.toString());
                        RESULT = n1 % n2;
                    :};

ESTADISTICA ::=  TK_MEDIA PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    double sum = 0;
                    int count = 0;
                    for (Object valor : datosC) {
                            sum += Double.parseDouble(valor.toString());
                            count++;
                        
                    }
                    double media = sum / count ;
                    RESULT = media;
                :}
                |TK_MEDIANA PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    double mediana = 0;
                    int size = datosC.size();
                    if (size % 2 == 0) {
                        mediana = (Double.parseDouble(datosC.get(size / 2 - 1).toString()) + Double.parseDouble(datosC.get(size / 2).toString())) / 2;
                    } else {
                        mediana = Double.parseDouble(datosC.get(size / 2).toString());
                    }
                    RESULT = mediana;
                :}
                |TK_MODA PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    int maximoVeces = 0;
                    double moda = 0;
                    for (int i = 0; i < datosC.size(); i++) {
                        int veces = 0;
                        for (int j = 0; j < datosC.size(); j++) {
                            if (datosC.get(i).equals(datosC.get(j))) {
                                veces++;
                            }
                        }
                        if (veces > maximoVeces) {
                            moda = Double.parseDouble(datosC.get(i).toString());
                            maximoVeces = veces;
                        }
                    }
                    RESULT = moda;
                :}
                |TK_VARIANZA PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    //para la varianza se necesita calcular la media aritmetica
                    double sum = 0;
                    for (Object valor : datosC) {
                            sum += Double.parseDouble(valor.toString());                      
                    }
                    double media = sum / datosC.size() ;
                    // por cada dato RESTAR este valor y elevar al cuadrado
                    double SUMparentesisCuadrados = 0;
                    for(Object valor: datosC){
                        double par = Double.parseDouble(valor.toString()) - media;
                        SUMparentesisCuadrados += par * par;
                    }
                    double varianza = SUMparentesisCuadrados /datosC.size();
                    RESULT = varianza;
                    

                :}

                |TK_MAX PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    Double maxV = Double.parseDouble(datosC.get(0).toString());
                    for(Object obj:datosC){
                    double num = Double.parseDouble(obj.toString());
                    if(num > maxV){
                        maxV = num;
                    }
                    }
                    RESULT = maxV;
                    
                :}
                |TK_MIN PARA DATOS:arrV PARC
                {:
                    ArrayList<Object> datosC = (ArrayList<Object>) arrV;
                    Double minV =  Double.parseDouble(datosC.get(0).toString());
                    for(Object obj:datosC){
                    double num = Double.parseDouble(obj.toString());
                    if(num < minV){
                        minV = num;
                    }
                    }
                    RESULT = minV;
                :};

//Esta produccion siempre retornara un arreglo
//asi que lo obtenido aca guardalo en un arreglo para su uso en operaciones o en impresiones
DATOS ::= IDARREGLO:arrID {:
        ArrayList<Object> datos = (ArrayList<Object>) data.get(arrID);
        RESULT = datos;
    :}
         | LISTA_VALORES:lista {: RESULT=lista; :};//y aca se retorna un arreglo que proviene de la produccion de listaValores

IMPRESION ::= TK_CONSOLE DOSP DOSP TIPOIMPRESION TK_END PYCOMA {: addPrintExpression("\n"); :} ;
//usar prinLNAdd para imprimir en consola en la misma linea, es decir añadir esa primera expresion
// sin salto y luego seguir añadiendo las demas expresiones sin salto hasta llegar al final 
//crear un printAdd con un salto de linea al final de todas las expresiones
TIPOIMPRESION ::= TK_PRINT IGUAL EXPRESION:e {: addPrintExpression(e.toString()); :} OTRAEXPRESIONIMP  
                | TK_COLUMN IGUAL EXPRESION:e MENOS MAYORQ ARREGLOIMP:arreglo
                {:
                    ArrayList<Object> datosImp = (ArrayList<Object>) arreglo;
                    //Aca quiero meter los datos del arreglo donde el titulo sera el e.toString()
                    //y los datos del arreglo agregar cada uno al addPrintExpression con salto de linea al final de cada uno
                    addPrintExpression("---------------------\n");
                    addPrintExpression(e.toString());
                    addPrintExpression("\n");
                    addPrintExpression("---------------------\n");
                    for(Object dato: datosImp){
                        addPrintExpression(dato.toString());
                        addPrintExpression("\n");
                    }
                    addPrintExpression("---------------------\n");

                :};

ARREGLOIMP ::= IDARREGLO:arrID {:
        ArrayList<Object> datos = (ArrayList<Object>) data.get(arrID);
        RESULT = datos;
    :}
            | LISTA_VALORES:lista {: RESULT=lista; :};//y aca se retorna un arreglo que proviene de la produccion de listaValores


OTRAEXPRESIONIMP ::= OTRAEXPRESIONIMP COMA EXPRESION:e {: addPrintExpression(e.toString()); :} 
                  | /* vacio */;

                  //Impresiones Terminadas
                  //TODO: GRAFICAS, installar la libreria de jfreechart para graficar
                  //crear una clase que se encargue de graficar y que reciba los datos de la grafica
                  //y la imagen que retorne la guarde en un archivo con el nombre de la grafica y mostrar esto 
                  // en el area de imagenes de la interfaz grafica


// Jfreechart
// DefaulCategoryDataset dataset = new DefaultCategoryDataset(); para graficas de barras
// DefaultPieDataset dataset = new DefaultPieDataset(); para graficas de pastel
// DefaultXYDataset dataset = new DefaultXYDataset(); para graficas de lineas
// HistogramDataset dataset = new HistogramDataset(); para graficas de histogramas


GRAFICA ::= TIPOGRAPH:tg PARA INSTRUCCION OTRAINSTRUCCION TK_EXEC TIPOGRAPH TK_END PYCOMA PARC TK_END PYCOMA;//En esta parte crear la grafica 

TIPOGRAPH ::= TK_GRAPHBAR {: RESULT = "bar"; :}
            | TK_GRAPHPIE {: RESULT = "pie"; :} 
            | TK_GRAPHLINE {: RESULT = "line"; :} 
            | TK_HISTOGRAM {: RESULT = "histogram"; :};

INSTRUCCION ::= TIPOINSTRUCCION DOSP DOSP TIPO IGUAL EXPRESIONGRAPH TK_END PYCOMA;

EXPRESIONGRAPH ::= EXPRESION 
                | LISTA_VALORES;

TIPOINSTRUCCION ::= TK_VALUES 
                    | TK_TITULO
                    | TK_LABEL 
                    | TK_EJEX 
                    | TK_EJEY 
                    | TK_TITULOX 
                    | TK_TITULOY;

OTRAINSTRUCCION ::= OTRAINSTRUCCION  INSTRUCCION 
                    | /* vacio */;

